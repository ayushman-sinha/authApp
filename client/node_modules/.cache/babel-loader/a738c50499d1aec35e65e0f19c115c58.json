{"ast":null,"code":"var JsonWebTokenError = require('./lib/JsonWebTokenError');\n\nvar NotBeforeError = require('./lib/NotBeforeError');\n\nvar TokenExpiredError = require('./lib/TokenExpiredError');\n\nvar decode = require('./decode');\n\nvar timespan = require('./lib/timespan');\n\nvar PS_SUPPORTED = require('./lib/psSupported');\n\nvar jws = require('jws');\n\nvar PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];\nvar RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nvar HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if (typeof options === 'function' && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  } //clone this object since we are going to mutate it.\n\n\n  options = Object.assign({}, options);\n  var done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function (err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString) {\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  var parts = jwtString.split('.');\n\n  if (parts.length !== 3) {\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  var decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, {\n      complete: true\n    });\n  } catch (err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  var header = decodedToken.header;\n  var getSecret;\n\n  if (typeof secretOrPublicKey === 'function') {\n    if (!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  } else {\n    getSecret = function (header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function (err, secretOrPublicKey) {\n    if (err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    var hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey) {\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      options.algorithms = ['none'];\n    }\n\n    if (!options.algorithms) {\n      options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') || ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS : ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;\n    }\n\n    if (!~options.algorithms.indexOf(decodedToken.header.alg)) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    var valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    var payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n      var match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      var invalid_issuer = typeof options.issuer === 'string' && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      var maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      var signature = decodedToken.signature;\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};","map":{"version":3,"names":["JsonWebTokenError","require","NotBeforeError","TokenExpiredError","decode","timespan","PS_SUPPORTED","jws","PUB_KEY_ALGS","RSA_KEY_ALGS","HS_ALGS","splice","module","exports","jwtString","secretOrPublicKey","options","callback","Object","assign","done","err","data","clockTimestamp","nonce","undefined","trim","Math","floor","Date","now","parts","split","length","decodedToken","complete","header","getSecret","secretCallback","message","hasSignature","algorithms","toString","indexOf","alg","valid","verify","e","payload","nbf","ignoreNotBefore","clockTolerance","exp","ignoreExpiration","audience","audiences","Array","isArray","target","aud","match","some","targetAudience","RegExp","test","join","issuer","invalid_issuer","iss","subject","sub","jwtid","jti","maxAge","iat","maxAgeTimestamp","signature"],"sources":["D:/React/authApp/client/node_modules/jsonwebtoken/verify.js"],"sourcesContent":["var JsonWebTokenError = require('./lib/JsonWebTokenError');\nvar NotBeforeError    = require('./lib/NotBeforeError');\nvar TokenExpiredError = require('./lib/TokenExpiredError');\nvar decode            = require('./decode');\nvar timespan          = require('./lib/timespan');\nvar PS_SUPPORTED      = require('./lib/psSupported');\nvar jws               = require('jws');\n\nvar PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];\nvar RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nvar HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if ((typeof options === 'function') && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n\n  var done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString){\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  var parts = jwtString.split('.');\n\n  if (parts.length !== 3){\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  var decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, { complete: true });\n  } catch(err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  var header = decodedToken.header;\n  var getSecret;\n\n  if(typeof secretOrPublicKey === 'function') {\n    if(!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  }\n  else {\n    getSecret = function(header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function(err, secretOrPublicKey) {\n    if(err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    var hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey){\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      options.algorithms = ['none'];\n    }\n\n    if (!options.algorithms) {\n      options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||\n        ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS :\n        ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;\n\n    }\n\n    if (!~options.algorithms.indexOf(decodedToken.header.alg)) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    var valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    var payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n      var match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      var invalid_issuer =\n              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\n              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      var maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      var signature = decodedToken.signature;\n\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}