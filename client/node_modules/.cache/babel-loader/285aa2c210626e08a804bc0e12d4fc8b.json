{"ast":null,"code":"import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n  let protectedB64u;\n\n  if (typeof token === 'string') {\n    const parts = token.split('.');\n\n    if (parts.length === 3 || parts.length === 5) {\n      ;\n      [protectedB64u] = parts;\n    }\n  } else if (typeof token === 'object' && token) {\n    if ('protected' in token) {\n      protectedB64u = token.protected;\n    } else {\n      throw new TypeError('Token does not contain a Protected Header');\n    }\n  }\n\n  try {\n    if (typeof protectedB64u !== 'string' || !protectedB64u) {\n      throw new Error();\n    }\n\n    const result = JSON.parse(decoder.decode(base64url(protectedB64u)));\n\n    if (!isObject(result)) {\n      throw new Error();\n    }\n\n    return result;\n  } catch (_a) {\n    throw new TypeError('Invalid Token or Protected Header formatting');\n  }\n}","map":{"version":3,"names":["decode","base64url","decoder","isObject","decodeProtectedHeader","token","protectedB64u","parts","split","length","protected","TypeError","Error","result","JSON","parse","_a"],"sources":["D:/React/authApp/client/node_modules/jose/dist/browser/util/decode_protected_header.js"],"sourcesContent":["import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(base64url(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch (_a) {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n"],"mappings":"AAAA,SAASA,MAAM,IAAIC,SAAnB,QAAoC,gBAApC;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,OAAOC,QAAP,MAAqB,qBAArB;AACA,OAAO,SAASC,qBAAT,CAA+BC,KAA/B,EAAsC;EACzC,IAAIC,aAAJ;;EACA,IAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;IAC3B,MAAME,KAAK,GAAGF,KAAK,CAACG,KAAN,CAAY,GAAZ,CAAd;;IACA,IAAID,KAAK,CAACE,MAAN,KAAiB,CAAjB,IAAsBF,KAAK,CAACE,MAAN,KAAiB,CAA3C,EAA8C;MAC1C;MACA,CAACH,aAAD,IAAkBC,KAAlB;IACH;EACJ,CAND,MAOK,IAAI,OAAOF,KAAP,KAAiB,QAAjB,IAA6BA,KAAjC,EAAwC;IACzC,IAAI,eAAeA,KAAnB,EAA0B;MACtBC,aAAa,GAAGD,KAAK,CAACK,SAAtB;IACH,CAFD,MAGK;MACD,MAAM,IAAIC,SAAJ,CAAc,2CAAd,CAAN;IACH;EACJ;;EACD,IAAI;IACA,IAAI,OAAOL,aAAP,KAAyB,QAAzB,IAAqC,CAACA,aAA1C,EAAyD;MACrD,MAAM,IAAIM,KAAJ,EAAN;IACH;;IACD,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWb,OAAO,CAACF,MAAR,CAAeC,SAAS,CAACK,aAAD,CAAxB,CAAX,CAAf;;IACA,IAAI,CAACH,QAAQ,CAACU,MAAD,CAAb,EAAuB;MACnB,MAAM,IAAID,KAAJ,EAAN;IACH;;IACD,OAAOC,MAAP;EACH,CATD,CAUA,OAAOG,EAAP,EAAW;IACP,MAAM,IAAIL,SAAJ,CAAc,8CAAd,CAAN;EACH;AACJ"},"metadata":{},"sourceType":"module"}