{"ast":null,"code":"import { decode as decodeBase64URL, encodeBase64, decodeBase64 } from '../runtime/base64url.js';\nimport { fromSPKI as importPublic } from '../runtime/asn1.js';\nimport { fromPKCS8 as importPrivate } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport formatPEM from '../lib/format_pem.js';\nimport isObject from '../lib/is_object.js';\n\nfunction getElement(seq) {\n  let result = [];\n  let next = 0;\n\n  while (next < seq.length) {\n    let nextPart = parseElement(seq.subarray(next));\n    result.push(nextPart);\n    next += nextPart.byteLength;\n  }\n\n  return result;\n}\n\nfunction parseElement(bytes) {\n  let position = 0;\n  let tag = bytes[0] & 0x1f;\n  position++;\n\n  if (tag === 0x1f) {\n    tag = 0;\n\n    while (bytes[position] >= 0x80) {\n      tag = tag * 128 + bytes[position] - 0x80;\n      position++;\n    }\n\n    tag = tag * 128 + bytes[position] - 0x80;\n    position++;\n  }\n\n  let length = 0;\n\n  if (bytes[position] < 0x80) {\n    length = bytes[position];\n    position++;\n  } else {\n    let numberOfDigits = bytes[position] & 0x7f;\n    position++;\n    length = 0;\n\n    for (let i = 0; i < numberOfDigits; i++) {\n      length = length * 256 + bytes[position];\n      position++;\n    }\n  }\n\n  if (length === 0x80) {\n    length = 0;\n\n    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n      length++;\n    }\n\n    const byteLength = position + length + 2;\n    return {\n      byteLength,\n      contents: bytes.subarray(position, position + length),\n      raw: bytes.subarray(0, byteLength)\n    };\n  }\n\n  const byteLength = position + length;\n  return {\n    byteLength,\n    contents: bytes.subarray(position, byteLength),\n    raw: bytes.subarray(0, byteLength)\n  };\n}\n\nfunction spkiFromX509(buf) {\n  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\n\nfunction getSPKI(x509) {\n  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n  const raw = decodeBase64(pem);\n  return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\n\nexport async function importSPKI(spki, alg, options) {\n  if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n    throw new TypeError('\"spki\" must be SPKI formatted string');\n  }\n\n  return importPublic(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n  if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n    throw new TypeError('\"x509\" must be X.509 formatted string');\n  }\n\n  const spki = getSPKI(x509);\n  return importPublic(spki, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n  if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n    throw new TypeError('\"pkcs8\" must be PCKS8 formatted string');\n  }\n\n  return importPrivate(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, octAsKeyObject) {\n  if (!isObject(jwk)) {\n    throw new TypeError('JWK must be an object');\n  }\n\n  alg || (alg = jwk.alg);\n\n  if (typeof alg !== 'string' || !alg) {\n    throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n  }\n\n  switch (jwk.kty) {\n    case 'oct':\n      if (typeof jwk.k !== 'string' || !jwk.k) {\n        throw new TypeError('missing \"k\" (Key Value) Parameter value');\n      }\n\n      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;\n\n      if (octAsKeyObject) {\n        return asKeyObject({ ...jwk,\n          alg,\n          ext: false\n        });\n      }\n\n      return decodeBase64URL(jwk.k);\n\n    case 'RSA':\n      if (jwk.oth !== undefined) {\n        throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n      }\n\n    case 'EC':\n    case 'OKP':\n      return asKeyObject({ ...jwk,\n        alg\n      });\n\n    default:\n      throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n  }\n}","map":{"version":3,"names":["decode","decodeBase64URL","encodeBase64","decodeBase64","fromSPKI","importPublic","fromPKCS8","importPrivate","asKeyObject","JOSENotSupported","formatPEM","isObject","getElement","seq","result","next","length","nextPart","parseElement","subarray","push","byteLength","bytes","position","tag","numberOfDigits","i","contents","raw","spkiFromX509","buf","tbsCertificate","getSPKI","x509","pem","replace","importSPKI","spki","alg","options","indexOf","TypeError","importX509","importPKCS8","pkcs8","importJWK","jwk","octAsKeyObject","kty","k","ext","oth","undefined"],"sources":["D:/React/authApp/client/node_modules/jose/dist/browser/key/import.js"],"sourcesContent":["import { decode as decodeBase64URL, encodeBase64, decodeBase64 } from '../runtime/base64url.js';\nimport { fromSPKI as importPublic } from '../runtime/asn1.js';\nimport { fromPKCS8 as importPrivate } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport formatPEM from '../lib/format_pem.js';\nimport isObject from '../lib/is_object.js';\nfunction getElement(seq) {\n    let result = [];\n    let next = 0;\n    while (next < seq.length) {\n        let nextPart = parseElement(seq.subarray(next));\n        result.push(nextPart);\n        next += nextPart.byteLength;\n    }\n    return result;\n}\nfunction parseElement(bytes) {\n    let position = 0;\n    let tag = bytes[0] & 0x1f;\n    position++;\n    if (tag === 0x1f) {\n        tag = 0;\n        while (bytes[position] >= 0x80) {\n            tag = tag * 128 + bytes[position] - 0x80;\n            position++;\n        }\n        tag = tag * 128 + bytes[position] - 0x80;\n        position++;\n    }\n    let length = 0;\n    if (bytes[position] < 0x80) {\n        length = bytes[position];\n        position++;\n    }\n    else {\n        let numberOfDigits = bytes[position] & 0x7f;\n        position++;\n        length = 0;\n        for (let i = 0; i < numberOfDigits; i++) {\n            length = length * 256 + bytes[position];\n            position++;\n        }\n    }\n    if (length === 0x80) {\n        length = 0;\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n            length++;\n        }\n        const byteLength = position + length + 2;\n        return {\n            byteLength,\n            contents: bytes.subarray(position, position + length),\n            raw: bytes.subarray(0, byteLength),\n        };\n    }\n    const byteLength = position + length;\n    return {\n        byteLength,\n        contents: bytes.subarray(position, byteLength),\n        raw: bytes.subarray(0, byteLength),\n    };\n}\nfunction spkiFromX509(buf) {\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const raw = decodeBase64(pem);\n    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return importPublic(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    const spki = getSPKI(x509);\n    return importPublic(spki, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PCKS8 formatted string');\n    }\n    return importPrivate(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, octAsKeyObject) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    if (typeof alg !== 'string' || !alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);\n            if (octAsKeyObject) {\n                return asKeyObject({ ...jwk, alg, ext: false });\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}