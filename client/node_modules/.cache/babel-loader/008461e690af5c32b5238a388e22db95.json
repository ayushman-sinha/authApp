{"ast":null,"code":"import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\n\nclass IndividualRecipient {\n  constructor(enc, key, options) {\n    this.parent = enc;\n    this.key = key;\n    this.options = options;\n  }\n\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this.unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n\n    this.unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n\n  addRecipient() {\n    return this.parent.addRecipient(...arguments);\n  }\n\n  encrypt() {\n    return this.parent.encrypt(...arguments);\n  }\n\n  done() {\n    return this.parent;\n  }\n\n}\n\nexport class GeneralEncrypt {\n  constructor(plaintext) {\n    this._recipients = [];\n    this._plaintext = plaintext;\n  }\n\n  addRecipient(key, options) {\n    const recipient = new IndividualRecipient(this, key, {\n      crit: options === null || options === void 0 ? void 0 : options.crit\n    });\n\n    this._recipients.push(recipient);\n\n    return recipient;\n  }\n\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setSharedUnprotectedHeader can only be called once');\n    }\n\n    this._unprotectedHeader = sharedUnprotectedHeader;\n    return this;\n  }\n\n  setAdditionalAuthenticatedData(aad) {\n    this._aad = aad;\n    return this;\n  }\n\n  async encrypt(options) {\n    var _a, _b, _c;\n\n    if (!this._recipients.length) {\n      throw new JWEInvalid('at least one recipient must be added');\n    }\n\n    options = {\n      deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw\n    };\n\n    if (this._recipients.length === 1) {\n      const [recipient] = this._recipients;\n      const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options,\n        ...options\n      });\n      let jwe = {\n        ciphertext: flattened.ciphertext,\n        iv: flattened.iv,\n        recipients: [{}],\n        tag: flattened.tag\n      };\n      if (flattened.aad) jwe.aad = flattened.aad;\n      if (flattened.protected) jwe.protected = flattened.protected;\n      if (flattened.unprotected) jwe.unprotected = flattened.unprotected;\n      if (flattened.encrypted_key) jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n      if (flattened.header) jwe.recipients[0].header = flattened.header;\n      return jwe;\n    }\n\n    let enc;\n\n    for (let i = 0; i < this._recipients.length; i++) {\n      const recipient = this._recipients[i];\n\n      if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n        throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n      }\n\n      const joseHeader = { ...this._protectedHeader,\n        ...this._unprotectedHeader,\n        ...recipient.unprotectedHeader\n      };\n      const {\n        alg\n      } = joseHeader;\n\n      if (typeof alg !== 'string' || !alg) {\n        throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n      }\n\n      if (alg === 'dir' || alg === 'ECDH-ES') {\n        throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n      }\n\n      if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n        throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n      }\n\n      if (!enc) {\n        enc = joseHeader.enc;\n      } else if (enc !== joseHeader.enc) {\n        throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n      }\n\n      validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n\n      if (joseHeader.zip !== undefined) {\n        if (!this._protectedHeader || !this._protectedHeader.zip) {\n          throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n        }\n      }\n    }\n\n    const cek = generateCek(enc);\n    let jwe = {\n      ciphertext: '',\n      iv: '',\n      recipients: [],\n      tag: ''\n    };\n\n    for (let i = 0; i < this._recipients.length; i++) {\n      const recipient = this._recipients[i];\n      const target = {};\n      jwe.recipients.push(target);\n      const joseHeader = { ...this._protectedHeader,\n        ...this._unprotectedHeader,\n        ...recipient.unprotectedHeader\n      };\n      const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n\n      if (i === 0) {\n        const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({\n          p2c\n        }).encrypt(recipient.key, { ...recipient.options,\n          ...options,\n          [unprotected]: true\n        });\n        jwe.ciphertext = flattened.ciphertext;\n        jwe.iv = flattened.iv;\n        jwe.tag = flattened.tag;\n        if (flattened.aad) jwe.aad = flattened.aad;\n        if (flattened.protected) jwe.protected = flattened.protected;\n        if (flattened.unprotected) jwe.unprotected = flattened.unprotected;\n        target.encrypted_key = flattened.encrypted_key;\n        if (flattened.header) target.header = flattened.header;\n        continue;\n      }\n\n      const {\n        encryptedKey,\n        parameters\n      } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, {\n        p2c\n      });\n      target.encrypted_key = base64url(encryptedKey);\n      if (recipient.unprotectedHeader || parameters) target.header = { ...recipient.unprotectedHeader,\n        ...parameters\n      };\n    }\n\n    return jwe;\n  }\n\n}","map":{"version":3,"names":["FlattenedEncrypt","unprotected","JWEInvalid","generateCek","isDisjoint","encryptKeyManagement","encode","base64url","validateCrit","IndividualRecipient","constructor","enc","key","options","parent","setUnprotectedHeader","unprotectedHeader","TypeError","addRecipient","encrypt","done","GeneralEncrypt","plaintext","_recipients","_plaintext","recipient","crit","push","setProtectedHeader","protectedHeader","_protectedHeader","setSharedUnprotectedHeader","sharedUnprotectedHeader","_unprotectedHeader","setAdditionalAuthenticatedData","aad","_aad","_a","_b","_c","length","deflateRaw","flattened","jwe","ciphertext","iv","recipients","tag","protected","encrypted_key","header","i","joseHeader","alg","Map","zip","undefined","cek","target","p2c","startsWith","setContentEncryptionKey","setKeyManagementParameters","encryptedKey","parameters"],"sources":["D:/React/authApp/client/node_modules/jose/dist/browser/jwe/general/encrypt.js"],"sourcesContent":["import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt(options) {\n        var _a, _b, _c;\n        if (!this._recipients.length) {\n            throw new JWEInvalid('at least one recipient must be added');\n        }\n        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options, ...options });\n            let jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                if (!this._protectedHeader || !this._protectedHeader.zip) {\n                    throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n                }\n            }\n        }\n        const cek = generateCek(enc);\n        let jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    ...options,\n                    [unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||\n                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||\n                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });\n            target.encrypted_key = base64url(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}