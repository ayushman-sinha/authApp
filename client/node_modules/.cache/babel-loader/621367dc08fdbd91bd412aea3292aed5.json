{"ast":null,"code":"import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\n\nconst normalizeTyp = value => value.toLowerCase().replace(/^application\\//, '');\n\nconst checkAudiencePresence = (audPayload, audOption) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload);\n  }\n\n  if (Array.isArray(audPayload)) {\n    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n  }\n\n  return false;\n};\n\nexport default (function (protectedHeader, encodedPayload) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    typ\n  } = options;\n\n  if (typ && (typeof protectedHeader.typ !== 'string' || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n    throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n  }\n\n  let payload;\n\n  try {\n    payload = JSON.parse(decoder.decode(encodedPayload));\n  } catch (_a) {}\n\n  if (!isObject(payload)) {\n    throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n  }\n\n  const {\n    issuer\n  } = options;\n\n  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n    throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n  }\n\n  const {\n    subject\n  } = options;\n\n  if (subject && payload.sub !== subject) {\n    throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n  }\n\n  const {\n    audience\n  } = options;\n\n  if (audience && !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n  }\n\n  let tolerance;\n\n  switch (typeof options.clockTolerance) {\n    case 'string':\n      tolerance = secs(options.clockTolerance);\n      break;\n\n    case 'number':\n      tolerance = options.clockTolerance;\n      break;\n\n    case 'undefined':\n      tolerance = 0;\n      break;\n\n    default:\n      throw new TypeError('Invalid clockTolerance option type');\n  }\n\n  const {\n    currentDate\n  } = options;\n  const now = epoch(currentDate || new Date());\n\n  if ((payload.iat !== undefined || options.maxTokenAge) && typeof payload.iat !== 'number') {\n    throw new JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n  }\n\n  if (payload.nbf !== undefined) {\n    if (typeof payload.nbf !== 'number') {\n      throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n    }\n\n    if (payload.nbf > now + tolerance) {\n      throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n    }\n  }\n\n  if (payload.exp !== undefined) {\n    if (typeof payload.exp !== 'number') {\n      throw new JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n    }\n\n    if (payload.exp <= now - tolerance) {\n      throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n    }\n  }\n\n  if (options.maxTokenAge) {\n    const age = now - payload.iat;\n    const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : secs(options.maxTokenAge);\n\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n    }\n\n    if (age < 0 - tolerance) {\n      throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n    }\n  }\n\n  return payload;\n});","map":{"version":3,"names":["JWTClaimValidationFailed","JWTExpired","JWTInvalid","decoder","epoch","secs","isObject","normalizeTyp","value","toLowerCase","replace","checkAudiencePresence","audPayload","audOption","includes","Array","isArray","some","Set","prototype","has","bind","protectedHeader","encodedPayload","options","typ","payload","JSON","parse","decode","_a","issuer","iss","subject","sub","audience","aud","tolerance","clockTolerance","TypeError","currentDate","now","Date","iat","undefined","maxTokenAge","nbf","exp","age","max"],"sources":["D:/React/authApp/client/node_modules/jose/dist/browser/lib/jwt_claims_set.js"],"sourcesContent":["import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n    }\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch (_a) {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { issuer } = options;\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n    }\n    const { subject } = options;\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n    }\n    const { audience } = options;\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || options.maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n        }\n    }\n    if (options.maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : secs(options.maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}