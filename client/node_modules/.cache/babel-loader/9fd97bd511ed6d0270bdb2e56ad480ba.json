{"ast":null,"code":"import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n  constructor(payload) {\n    if (!(payload instanceof Uint8Array)) {\n      throw new TypeError('payload must be an instance of Uint8Array');\n    }\n\n    this._payload = payload;\n  }\n\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n\n    this._unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n\n  async sign(key, options) {\n    if (!this._protectedHeader && !this._unprotectedHeader) {\n      throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n    }\n\n    if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    const joseHeader = { ...this._protectedHeader,\n      ...this._unprotectedHeader\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n    let b64 = true;\n\n    if (extensions.has('b64')) {\n      b64 = this._protectedHeader.b64;\n\n      if (typeof b64 !== 'boolean') {\n        throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n      }\n    }\n\n    const {\n      alg\n    } = joseHeader;\n\n    if (typeof alg !== 'string' || !alg) {\n      throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n\n    checkKeyType(alg, key, 'sign');\n    let payload = this._payload;\n\n    if (b64) {\n      payload = encoder.encode(base64url(payload));\n    }\n\n    let protectedHeader;\n\n    if (this._protectedHeader) {\n      protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n    } else {\n      protectedHeader = encoder.encode('');\n    }\n\n    const data = concat(protectedHeader, encoder.encode('.'), payload);\n    const signature = await sign(alg, key, data);\n    const jws = {\n      signature: base64url(signature),\n      payload: ''\n    };\n\n    if (b64) {\n      jws.payload = decoder.decode(payload);\n    }\n\n    if (this._unprotectedHeader) {\n      jws.header = this._unprotectedHeader;\n    }\n\n    if (this._protectedHeader) {\n      jws.protected = decoder.decode(protectedHeader);\n    }\n\n    return jws;\n  }\n\n}","map":{"version":3,"names":["encode","base64url","sign","isDisjoint","JWSInvalid","encoder","decoder","concat","checkKeyType","validateCrit","FlattenedSign","constructor","payload","Uint8Array","TypeError","_payload","setProtectedHeader","protectedHeader","_protectedHeader","setUnprotectedHeader","unprotectedHeader","_unprotectedHeader","key","options","joseHeader","extensions","Map","crit","b64","has","alg","JSON","stringify","data","signature","jws","decode","header","protected"],"sources":["D:/React/authApp/client/node_modules/jose/dist/browser/jws/flattened/sign.js"],"sourcesContent":["import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}